<input type="color" id="input-color" value="#FF0000" />
<label for="input-color">the extract color</label>
<button id="separateButton">Generate the image</button>

<script>
  let HEX_COLOR = "#FF0000"

  document.getElementById("input-color").onchange = (e) => {
    HEX_COLOR = e.target.value
  }

  document.getElementById("separateButton").onclick = () => {
    parent.postMessage({ pluginMessage: { type: "separate-color-channels", color: HEX_COLOR } }, "*")
  }

  // Create an event handler to receive messages from the main thread.
  window.onmessage = async (event) => {
    // Just get the bytes and color from the pluginMessage.
    const bytes = event.data.pluginMessage.bytes
    const hexInputColor = event.data.pluginMessage.color

    const canvas = document.createElement("canvas")
    const ctx = canvas.getContext("2d")

    const imageData = await decode(canvas, ctx, bytes)
    const pixels = imageData.data

    const { r, g, b } = hexToRgb(hexInputColor)

    for (let i = 0; i < pixels.length; i += 4) {
      const pixelR = pixels[i]
      const pixelG = pixels[i + 1]
      const pixelB = pixels[i + 2]
      const alpha = pixels[i + 3]

      // Calculate the difference between the pixel color and the target color
      const diff = Math.sqrt(Math.pow(pixelR - r, 2) + Math.pow(pixelG - g, 2) + Math.pow(pixelB - b, 2))

      // If the difference is greater than a threshold, set the pixel to transparent
      const threshold = 50 // Change this to adjust the sensitivity of the color extraction
      if (diff > threshold) {
        pixels[i + 3] = 0
      }
    }

    const newBytes = await encode(canvas, ctx, imageData)

    window.parent.postMessage({ pluginMessage: newBytes }, "*")
  }

  function hexToRgb(hex) {
    const match = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b).match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i)
    return match ? { r: parseInt(match[1], 16), g: parseInt(match[2], 16), b: parseInt(match[3], 16) } : null
  }

  // Encoding an image
  async function encode(canvas, ctx, imageData) {
    ctx.putImageData(imageData, 0, 0)
    return await new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        const reader = new FileReader()
        reader.onload = () => resolve(new Uint8Array(reader.result))
        reader.onerror = () => reject(new Error("Could not read from blob"))
        reader.readAsArrayBuffer(blob)
      })
    })
  }

  // Decoding an image
  async function decode(canvas, ctx, bytes) {
    const url = URL.createObjectURL(new Blob([bytes]))
    const image = await new Promise((resolve, reject) => {
      const img = new Image()
      img.onload = () => resolve(img)
      img.onerror = () => reject()
      img.src = url
    })
    canvas.width = image.width
    canvas.height = image.height
    ctx.drawImage(image, 0, 0)
    const imageData = ctx.getImageData(0, 0, image.width, image.height)
    return imageData
  }
</script>
